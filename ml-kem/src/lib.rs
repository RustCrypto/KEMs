#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![doc = include_str!("../README.md")]
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/RustCrypto/meta/master/logo.svg",
    html_favicon_url = "https://raw.githubusercontent.com/RustCrypto/meta/master/logo.svg"
)]
#![allow(non_snake_case)] // Allow notation matching the spec
#![allow(clippy::clone_on_copy)] // Be explicit about moving data
#![deny(missing_docs)] // Require all public interfaces to be documented
#![warn(clippy::pedantic)] // Be pedantic by default
#![warn(clippy::integer_division_remainder_used)] // Be judicious about using `/` and `%`

//! # Usage
//!
//! This crate implements the Module-Latice-based Key Encapsulation Method (ML-KEM) algorithm
//! being standardized by NIST in FIPS 203.  ML-KEM is a KEM in the sense that it creates an
//! (decapsulation key, encapsulation key) pair, such that anyone can use the encapsulation key to
//! establish a shared key with the holder of the decapsulation key.  ML-KEM is the first KEM
//! algorithm standardized by NIST that is designed to be resistant to attacks using quantum
//! computers.
//!
//! ```
//! # use ml_kem::*;
//! # use ::kem::{Decapsulate, Encapsulate};
//! let mut rng = rand::rng();
//!
//! // Generate a (decapsulation key, encapsulation key) pair
//! let (dk, ek) = MlKem768::generate(&mut rng);
//!
//! // Encapsulate a shared key to the holder of the decapsulation key, receive the shared
//! // secret `k_send` and the encapsulated form `ct`.
//! let (ct, k_send) = ek.encapsulate(&mut rng).unwrap();
//!
//! // Decapsulate the shared key and verify that it was faithfully received.
//! let k_recv = dk.decapsulate(&ct).unwrap();
//! assert_eq!(k_send, k_recv);
//! ```
//!
//! [RFC 9180]: https://www.rfc-editor.org/info/rfc9180

/// The inevitable utility module
mod util;

/// Section 2.4. Interpreting the Pseudocode
/// Section 4.2.2. Sampling algorithms
/// Section 4.3. The Number-Theoretic Transform
mod algebra;

/// Section 4.1. Crytographic Functions
mod crypto;

/// Section 4.2.1. Conversion and Compression Algorithms, Compression and decompression
mod compress;

/// Section 4.2.1. Conversion and Compression Algorithms, Encoding and decoding
mod encode;

/// Section 5. The K-PKE Component Scheme
mod pke;

/// Section 6. The ML-KEM Key-Encapsulation Mechanism
pub mod kem;

/// Section 7. Parameter Sets
mod param;

use ::kem::{Decapsulate, Encapsulate};
use core::fmt::Debug;
use hybrid_array::{
    Array,
    typenum::{U2, U3, U4, U5, U10, U11},
};
use rand_core::CryptoRng;

pub use hybrid_array as array;

#[cfg(feature = "deterministic")]
pub use util::B32;

pub use param::{ArraySize, ParameterSet};

#[cfg(feature = "pkcs8")]
pub use pkcs8;

#[cfg(feature = "pkcs8")]
use pkcs8::AssociatedOid;

/// An object that knows what size it is
pub trait EncodedSizeUser {
    /// The size of an encoded object
    type EncodedSize: ArraySize;

    /// Parse an object from its encoded form
    fn from_bytes(enc: &Encoded<Self>) -> Self;

    /// Serialize an object to its encoded form
    fn as_bytes(&self) -> Encoded<Self>;
}

/// A byte array encoding a value the indicated size
pub type Encoded<T> = Array<u8, <T as EncodedSizeUser>::EncodedSize>;

/// A value that can be encapsulated to.  Note that this interface is not safe: In order for the
/// KEM to be secure, the `m` input must be randomly generated.
#[cfg(feature = "deterministic")]
pub trait EncapsulateDeterministic<EK, SS> {
    /// Encapsulation error
    type Error: Debug;

    /// Encapsulates a fresh shared secret.
    ///
    /// # Errors
    ///
    /// Will vary depending on the underlying implementation.
    fn encapsulate_deterministic(&self, m: &B32) -> Result<(EK, SS), Self::Error>;
}

/// A generic interface to a Key Encapsulation Method
pub trait KemCore: Clone {
    /// The size of a shared key generated by this KEM
    type SharedKeySize: ArraySize;

    /// The size of a ciphertext encapsulating a shared key
    type CiphertextSize: ArraySize;

    /// A decapsulation key for this KEM
    type DecapsulationKey: Decapsulate<Ciphertext<Self>, SharedKey<Self>>
        + EncodedSizeUser
        + Debug
        + PartialEq;

    /// An encapsulation key for this KEM
    #[cfg(not(feature = "deterministic"))]
    type EncapsulationKey: Encapsulate<Ciphertext<Self>, SharedKey<Self>>
        + EncodedSizeUser
        + Clone
        + Debug
        + PartialEq;

    /// An encapsulation key for this KEM
    #[cfg(feature = "deterministic")]
    type EncapsulationKey: Encapsulate<Ciphertext<Self>, SharedKey<Self>>
        + EncapsulateDeterministic<Ciphertext<Self>, SharedKey<Self>>
        + EncodedSizeUser
        + Clone
        + Debug
        + PartialEq;

    /// Generate a new (decapsulation, encapsulation) key pair
    fn generate<R: CryptoRng + ?Sized>(
        rng: &mut R,
    ) -> (Self::DecapsulationKey, Self::EncapsulationKey);

    /// Generate a new (decapsulation, encapsulation) key pair deterministically
    #[cfg(feature = "deterministic")]
    fn generate_deterministic(d: &B32, z: &B32)
    -> (Self::DecapsulationKey, Self::EncapsulationKey);
}

/// `MlKem512` is the parameter set for security category 1, corresponding to key search on a block
/// cipher with a 128-bit key.
#[derive(Default, Clone, Debug, PartialEq)]
pub struct MlKem512Params;

impl ParameterSet for MlKem512Params {
    type K = U2;
    type Eta1 = U3;
    type Eta2 = U2;
    type Du = U10;
    type Dv = U4;
}

#[cfg(feature = "pkcs8")]
impl AssociatedOid for MlKem512Params {
    const OID: pkcs8::ObjectIdentifier = const_oid::db::fips203::ID_ALG_ML_KEM_512;
}

#[cfg(feature = "pkcs8")]
impl pkcs8::spki::AssociatedAlgorithmIdentifier for MlKem512Params {
    type Params = pkcs8::der::AnyRef<'static>;

    const ALGORITHM_IDENTIFIER: pkcs8::spki::AlgorithmIdentifier<Self::Params> =
        pkcs8::spki::AlgorithmIdentifier {
            oid: Self::OID,
            parameters: None,
        };
}

/// `MlKem768` is the parameter set for security category 3, corresponding to key search on a block
/// cipher with a 192-bit key.
#[derive(Default, Clone, Debug, PartialEq)]
pub struct MlKem768Params;

impl ParameterSet for MlKem768Params {
    type K = U3;
    type Eta1 = U2;
    type Eta2 = U2;
    type Du = U10;
    type Dv = U4;
}

#[cfg(feature = "pkcs8")]
impl AssociatedOid for MlKem768Params {
    const OID: pkcs8::ObjectIdentifier = const_oid::db::fips203::ID_ALG_ML_KEM_768;
}

#[cfg(feature = "pkcs8")]
impl pkcs8::spki::AssociatedAlgorithmIdentifier for MlKem768Params {
    type Params = pkcs8::der::AnyRef<'static>;

    const ALGORITHM_IDENTIFIER: pkcs8::spki::AlgorithmIdentifier<Self::Params> =
        pkcs8::spki::AlgorithmIdentifier {
            oid: Self::OID,
            parameters: None,
        };
}

/// `MlKem1024` is the parameter set for security category 5, corresponding to key search on a block
/// cipher with a 256-bit key.
#[derive(Default, Clone, Debug, PartialEq)]
pub struct MlKem1024Params;

impl ParameterSet for MlKem1024Params {
    type K = U4;
    type Eta1 = U2;
    type Eta2 = U2;
    type Du = U11;
    type Dv = U5;
}

#[cfg(feature = "pkcs8")]
impl AssociatedOid for MlKem1024Params {
    const OID: pkcs8::ObjectIdentifier = const_oid::db::fips203::ID_ALG_ML_KEM_1024;
}

#[cfg(feature = "pkcs8")]
impl pkcs8::spki::AssociatedAlgorithmIdentifier for MlKem1024Params {
    type Params = pkcs8::der::AnyRef<'static>;

    const ALGORITHM_IDENTIFIER: pkcs8::spki::AlgorithmIdentifier<Self::Params> =
        pkcs8::spki::AlgorithmIdentifier {
            oid: Self::OID,
            parameters: None,
        };
}

/// A shared key produced by the KEM `K`
pub type SharedKey<K> = Array<u8, <K as KemCore>::SharedKeySize>;

/// A ciphertext produced by the KEM `K`
pub type Ciphertext<K> = Array<u8, <K as KemCore>::CiphertextSize>;

/// ML-KEM with the parameter set for security category 1, corresponding to key search on a block
/// cipher with a 128-bit key.
pub type MlKem512 = kem::Kem<MlKem512Params>;

/// ML-KEM with the parameter set for security category 3, corresponding to key search on a block
/// cipher with a 192-bit key.
pub type MlKem768 = kem::Kem<MlKem768Params>;

/// ML-KEM with the parameter set for security category 5, corresponding to key search on a block
/// cipher with a 256-bit key.
pub type MlKem1024 = kem::Kem<MlKem1024Params>;

#[cfg(test)]
mod test {
    use super::*;
    #[cfg(all(feature = "pkcs8", feature = "alloc", feature = "pem"))]
    use crate::kem::PrivateKeyBothChoice;
    #[cfg(all(feature = "pkcs8", feature = "alloc"))]
    use crate::kem::PrivateKeyChoice;
    #[cfg(all(feature = "pkcs8", feature = "alloc"))]
    use pkcs8::der::{self, Decode};
    #[cfg(all(feature = "pkcs8", feature = "alloc"))]
    use pkcs8::{
        DecodePrivateKey, DecodePublicKey, EncodePrivateKey, EncodePublicKey, PrivateKeyInfoRef,
        SubjectPublicKeyInfoRef,
    };

    fn round_trip_test<K>()
    where
        K: KemCore,
    {
        let mut rng = rand::rng();

        let (dk, ek) = K::generate(&mut rng);

        let (ct, k_send) = ek.encapsulate(&mut rng).unwrap();
        let k_recv = dk.decapsulate(&ct).unwrap();
        assert_eq!(k_send, k_recv);
    }

    #[test]
    fn round_trip() {
        round_trip_test::<MlKem512>();
        round_trip_test::<MlKem768>();
        round_trip_test::<MlKem1024>();
    }

    #[cfg(all(feature = "pkcs8", feature = "alloc"))]
    fn der_serialization_and_deserialization<K>(expected_encaps_len: u32, expected_decaps_len: u32)
    where
        K: KemCore,
        K::EncapsulationKey: EncodePublicKey + DecodePublicKey,
        K::DecapsulationKey: EncodePrivateKey + DecodePrivateKey,
    {
        let mut rng = rand::rng();
        let (decaps_key, encaps_key) = K::generate(&mut rng);

        // TEST: (de)serialize encapsulation key into DER document
        {
            let der_document = encaps_key.to_public_key_der().unwrap();
            let serialized_document = der_document.as_bytes();

            // deserialize encapsulation key from DER document
            let parsed = der::Document::from_der(serialized_document).unwrap();
            assert_eq!(parsed.len(), der::Length::new(expected_encaps_len));

            // verify that original encapsulation key corresponds to deserialized encapsulation key
            let pub_key = parsed.decode_msg::<SubjectPublicKeyInfoRef>().unwrap();
            assert_eq!(
                encaps_key.as_bytes().as_slice(),
                pub_key.subject_public_key.as_bytes().unwrap()
            );
        }

        // TEST: (de)serialize encapsulation key into DER document with the blanket implementation for DecodePublicKey
        {
            let der_document = encaps_key.to_public_key_der().unwrap();
            let serialized_document = der_document.as_bytes();

            // deserialize encapsulation key from DER document
            let parsed = K::EncapsulationKey::from_public_key_der(serialized_document).unwrap();

            // verify that original encapsulation key corresponds to deserialized encapsulation key
            assert_eq!(parsed, encaps_key);
        }

        // TEST: (de)serialize decapsulation key into DER document
        {
            let der_document = decaps_key.to_pkcs8_der().unwrap();
            let serialized_document = der_document.as_bytes();

            // deserialize decapsulation key from DER document
            let secret_document = der::SecretDocument::from_pkcs8_der(serialized_document).unwrap();
            assert_eq!(secret_document.len(), der::Length::new(expected_decaps_len));
            assert_eq!(secret_document.as_bytes(), der_document.as_bytes());

            // verify that original decapsulation key corresponds to deserialized decapsulation key
            let priv_key = secret_document.decode_msg::<PrivateKeyInfoRef>().unwrap();

            if let Ok(PrivateKeyChoice::Expanded(expanded)) = priv_key.private_key.decode_into() {
                assert_eq!(decaps_key.as_bytes().as_slice(), expanded.as_bytes());
            } else {
                panic!("unexpected PrivateKey serialization");
            }
        }

        // TEST: (de)serialize decapsulation key into DER document with the blanket implementation for DecodePrivateKey
        {
            let der_document = decaps_key.to_pkcs8_der().unwrap();
            let serialized_document = der_document.as_bytes();

            // deserialize decapsulation key from DER document
            let parsed = K::DecapsulationKey::from_pkcs8_der(serialized_document).unwrap();

            // verify that original decapsulation key corresponds to deserialized decapsulation key
            assert_eq!(parsed, decaps_key);
        }
    }

    #[cfg(all(feature = "pkcs8", feature = "alloc"))]
    #[test]
    fn pkcs8_serialize_and_deserialize_round_trip() {
        // NOTE: standardized encapsulation key sizes for MlKem{512,768,1024} are {800,1184,1568} bytes respectively.
        //       DER serialization adds 22 bytes. Thus we expect a length of {822,1206,1590} respectively.
        // NOTE: standardized decapsulation key sizes for MlKem{512,768,1024} are {1632,2400,3168} bytes respectively.
        //       DER serialization adds 28 bytes. Thus we expect a length of {1660,2428,3196} respectively.
        der_serialization_and_deserialization::<MlKem512>(822, 1660);
        der_serialization_and_deserialization::<MlKem768>(1206, 2428);
        der_serialization_and_deserialization::<MlKem1024>(1590, 3196);
    }

    #[cfg(all(feature = "pkcs8", feature = "alloc", feature = "pem"))]
    fn compare_with_reference_keys<K>(variant: usize, ref_pub_key_pem: &str, ref_priv_key_pem: &str)
    where
        K: KemCore,
        K::EncapsulationKey: EncodePublicKey,
        K::DecapsulationKey: EncodePrivateKey,
    {
        // auxiliary RNG implementation for a static seed
        struct SeedBasedRng {
            index: usize,
            seed: [u8; SEED_LEN],
        }

        impl rand_core::RngCore for SeedBasedRng {
            fn next_u32(&mut self) -> u32 {
                let mut buf = [0u8; 4];
                self.fill_bytes(&mut buf);
                u32::from_be_bytes(buf)
            }

            fn next_u64(&mut self) -> u64 {
                let mut buf = [0u8; 8];
                self.fill_bytes(&mut buf);
                u64::from_be_bytes(buf)
            }

            fn fill_bytes(&mut self, dst: &mut [u8]) {
                for item in dst {
                    *item = self.seed[self.index];
                    self.index = self.index.wrapping_add(1) & ((1 << SEED_LEN.ilog2()) - 1);
                }
            }
        }

        impl CryptoRng for SeedBasedRng {}

        const SEED_LEN: usize = 64;
        assert_eq!(SEED_LEN & (SEED_LEN - 1), 0);

        let seed: [u8; SEED_LEN] = core::array::from_fn(|i| u8::try_from(i).unwrap());
        let mut rng = SeedBasedRng { seed, index: 0 };
        let (decaps_key, encaps_key) = K::generate(&mut rng);

        let gen_pub_key_pem = encaps_key
            .to_public_key_pem(pkcs8::LineEnding::LF)
            .expect("serialization works");
        let gen_priv_key_pem = decaps_key
            .to_pkcs8_pem(pkcs8::LineEnding::LF)
            .expect("serialization works");

        {
            // TEST: DER document of public key must match
            let gen_pub_key_der = encaps_key.to_public_key_der().expect("serialization works");
            let ref_pub_key_der = der::Document::from_pem(ref_pub_key_pem)
                .expect("can read pubkey PEM document")
                .1;
            assert_eq!(gen_pub_key_der, ref_pub_key_der);
        }

        // TEST: PEM document of public key must match
        assert_eq!(
            gen_pub_key_pem, ref_pub_key_pem,
            "key generated from static seed and reference public key for ML-KEM-{variant} do not match"
        );
        // TEST: PEM document of private key must match
        assert_eq!(
            gen_priv_key_pem.as_str(),
            ref_priv_key_pem,
            "key generated from static seed and reference private key for ML-KEM-{variant} do not match"
        );
    }

    #[cfg(all(feature = "pkcs8", feature = "alloc", feature = "pem"))]
    #[test]
    fn pkcs8_generate_same_keys_like_golang_for_static_seed() {
        // NOTE: test vector files come from https://github.com/lamps-wg/kyber-certificates/tree/624bcaa4bd9ea9e72de5b51d81ce2d90cbd7e54a
        const PEM_512_PUB: &str = include_str!("../tests/examples/ML-KEM-512.pub");
        const PEM_768_PUB: &str = include_str!("../tests/examples/ML-KEM-768.pub");
        const PEM_1024_PUB: &str = include_str!("../tests/examples/ML-KEM-1024.pub");
        const PEM_512_PRIV: &str = include_str!("../tests/examples/ML-KEM-512-expanded.priv");
        const PEM_768_PRIV: &str = include_str!("../tests/examples/ML-KEM-768-expanded.priv");
        const PEM_1024_PRIV: &str = include_str!("../tests/examples/ML-KEM-1024-expanded.priv");

        compare_with_reference_keys::<MlKem512>(512, PEM_512_PUB, PEM_512_PRIV);
        compare_with_reference_keys::<MlKem768>(768, PEM_768_PUB, PEM_768_PRIV);
        compare_with_reference_keys::<MlKem1024>(1024, PEM_1024_PUB, PEM_1024_PRIV);
    }

    #[cfg(all(feature = "pkcs8", feature = "alloc", feature = "pem"))]
    #[test]
    fn pkcs8_can_read_reference_private_keys() {
        // NOTE: test vector files come from https://github.com/lamps-wg/kyber-certificates/tree/624bcaa4bd9ea9e72de5b51d81ce2d90cbd7e54a
        const PEM_512_SEED: &str = include_str!("../tests/examples/ML-KEM-512-seed.priv");
        const PEM_512_EXPANDED: &str = include_str!("../tests/examples/ML-KEM-512-expanded.priv");
        const PEM_512_BOTH: &str = include_str!("../tests/examples/ML-KEM-512-both.priv");
        const PEM_768_SEED: &str = include_str!("../tests/examples/ML-KEM-768-seed.priv");
        const PEM_768_EXPANDED: &str = include_str!("../tests/examples/ML-KEM-768-expanded.priv");
        const PEM_768_BOTH: &str = include_str!("../tests/examples/ML-KEM-768-both.priv");
        const PEM_1024_SEED: &str = include_str!("../tests/examples/ML-KEM-1024-seed.priv");
        const PEM_1024_EXPANDED: &str = include_str!("../tests/examples/ML-KEM-1024-expanded.priv");
        const PEM_1024_BOTH: &str = include_str!("../tests/examples/ML-KEM-1024-both.priv");

        fn expect_seed_bytes(ref_pem: &str, expected_seed_prefix: &[u8]) {
            let length = expected_seed_prefix.len();
            let secret_document = der::SecretDocument::from_pkcs8_pem(ref_pem)
                .expect("can read reference PEM private key file");
            let priv_key = secret_document.decode_msg::<PrivateKeyInfoRef>().unwrap();

            let given_prefix = match priv_key
                .private_key
                .decode_into()
                .expect("could not read internal structure of PEM private key")
            {
                PrivateKeyChoice::Seed(seed)
                | PrivateKeyChoice::Both(PrivateKeyBothChoice { seed, .. }) => {
                    &seed.as_bytes()[0..length]
                }
                PrivateKeyChoice::Expanded(_) => return,
            };

            assert_eq!(given_prefix, expected_seed_prefix);
        }

        fn expect_expanded_bytes(ref_pem: &str, expected_expanded_prefix: &[u8]) {
            let length = expected_expanded_prefix.len();
            let secret_document = der::SecretDocument::from_pkcs8_pem(ref_pem)
                .expect("can read reference PEM private key file");
            let priv_key = secret_document.decode_msg::<PrivateKeyInfoRef>().unwrap();

            let given_prefix = match priv_key
                .private_key
                .decode_into()
                .expect("could not read internal expanded structure of PEM private key")
            {
                PrivateKeyChoice::Seed(_) => return,
                PrivateKeyChoice::Expanded(expanded)
                | PrivateKeyChoice::Both(PrivateKeyBothChoice { expanded, .. }) => {
                    &expanded.as_bytes()[0..length]
                }
            };

            assert_eq!(given_prefix, expected_expanded_prefix);
        }

        const STATIC_SEED_PREFIX: &[u8] =
            &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17];
        const EXPANDED_512_KEY_PREFIX: &[u8] = &[0x70, 0x55, 0x4f, 0xd4, 0x36, 0x34, 0x4f, 0x27];
        const EXPANDED_768_KEY_PREFIX: &[u8] = &[0x27, 0xd2, 0xa7, 0x7f, 0x33, 0x75, 0x6f, 0x61];
        const EXPANDED_1024_KEY_PREFIX: &[u8] = &[0xf7, 0x7b, 0x7f, 0x6b, 0x15, 0xc7, 0x3f, 0xe2];

        expect_seed_bytes(PEM_512_SEED, STATIC_SEED_PREFIX);
        expect_expanded_bytes(PEM_512_EXPANDED, EXPANDED_512_KEY_PREFIX);
        expect_seed_bytes(PEM_512_BOTH, STATIC_SEED_PREFIX);
        expect_expanded_bytes(PEM_512_BOTH, EXPANDED_512_KEY_PREFIX);

        expect_seed_bytes(PEM_768_SEED, STATIC_SEED_PREFIX);
        expect_expanded_bytes(PEM_768_EXPANDED, EXPANDED_768_KEY_PREFIX);
        expect_seed_bytes(PEM_768_BOTH, STATIC_SEED_PREFIX);
        expect_expanded_bytes(PEM_768_BOTH, EXPANDED_768_KEY_PREFIX);

        expect_seed_bytes(PEM_1024_SEED, STATIC_SEED_PREFIX);
        expect_expanded_bytes(PEM_1024_EXPANDED, EXPANDED_1024_KEY_PREFIX);
        expect_seed_bytes(PEM_1024_BOTH, STATIC_SEED_PREFIX);
        expect_expanded_bytes(PEM_1024_BOTH, EXPANDED_1024_KEY_PREFIX);
    }
}
