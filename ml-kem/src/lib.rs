#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![doc = include_str!("../README.md")]
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/RustCrypto/meta/master/logo.svg",
    html_favicon_url = "https://raw.githubusercontent.com/RustCrypto/meta/master/logo.svg"
)]
#![allow(non_snake_case)] // Allow notation matching the spec
#![allow(clippy::clone_on_copy)] // Be explicit about moving data
#![deny(missing_docs)] // Require all public interfaces to be documented
#![warn(clippy::pedantic)] // Be pedantic by default
#![warn(clippy::integer_division_remainder_used)] // Be judicious about using `/` and `%`

//! # Usage
//!
//! This crate implements the Module-Latice-based Key Encapsulation Method (ML-KEM) algorithm
//! being standardized by NIST in FIPS 203.  ML-KEM is a KEM in the sense that it creates an
//! (decapsulation key, encapsulation key) pair, such that anyone can use the encapsulation key to
//! establish a shared key with the holder of the decapsulation key.  ML-KEM is the first KEM
//! algorithm standardized by NIST that is designed to be resistant to attacks using quantum
//! computers.
//!
//! ```
//! # use ml_kem::*;
//! # use ::kem::{Decapsulate, Encapsulate};
//! let mut rng = rand::rng();
//!
//! // Generate a (decapsulation key, encapsulation key) pair
//! let (dk, ek) = MlKem768::generate(&mut rng);
//!
//! // Encapsulate a shared key to the holder of the decapsulation key, receive the shared
//! // secret `k_send` and the encapsulated form `ct`.
//! let (ct, k_send) = ek.encapsulate(&mut rng).unwrap();
//!
//! // Decapsulate the shared key and verify that it was faithfully received.
//! let k_recv = dk.decapsulate(&ct).unwrap();
//! assert_eq!(k_send, k_recv);
//! ```
//!
//! [RFC 9180]: https://www.rfc-editor.org/info/rfc9180

/// The inevitable utility module
mod util;

/// Section 2.4. Interpreting the Pseudocode
/// Section 4.2.2. Sampling algorithms
/// Section 4.3. The Number-Theoretic Transform
mod algebra;

/// Section 4.1. Crytographic Functions
mod crypto;

/// Section 4.2.1. Conversion and Compression Algorithms, Compression and decompression
mod compress;

/// Section 4.2.1. Conversion and Compression Algorithms, Encoding and decoding
mod encode;

/// Section 5. The K-PKE Component Scheme
mod pke;

/// Section 6. The ML-KEM Key-Encapsulation Mechanism
pub mod kem;

/// Section 7. Parameter Sets
mod param;

use ::kem::{Decapsulate, Encapsulate};
use core::fmt::Debug;
use hybrid_array::{
    Array,
    typenum::{U2, U3, U4, U5, U10, U11},
};
use rand_core::CryptoRng;

pub use hybrid_array as array;

#[cfg(feature = "deterministic")]
pub use util::B32;

pub use param::{ArraySize, ParameterSet};

#[cfg(feature = "pkcs8")]
pub use pkcs8;

#[cfg(feature = "pkcs8")]
use pkcs8::AssociatedOid;

/// An object that knows what size it is
pub trait EncodedSizeUser {
    /// The size of an encoded object
    type EncodedSize: ArraySize;

    /// Parse an object from its encoded form
    fn from_bytes(enc: &Encoded<Self>) -> Self;

    /// Serialize an object to its encoded form
    fn as_bytes(&self) -> Encoded<Self>;
}

/// A byte array encoding a value the indicated size
pub type Encoded<T> = Array<u8, <T as EncodedSizeUser>::EncodedSize>;

/// A value that can be encapsulated to.  Note that this interface is not safe: In order for the
/// KEM to be secure, the `m` input must be randomly generated.
#[cfg(feature = "deterministic")]
pub trait EncapsulateDeterministic<EK, SS> {
    /// Encapsulation error
    type Error: Debug;

    /// Encapsulates a fresh shared secret.
    ///
    /// # Errors
    ///
    /// Will vary depending on the underlying implementation.
    fn encapsulate_deterministic(&self, m: &B32) -> Result<(EK, SS), Self::Error>;
}

/// A generic interface to a Key Encapsulation Method
pub trait KemCore: Clone {
    /// The size of a shared key generated by this KEM
    type SharedKeySize: ArraySize;

    /// The size of a ciphertext encapsulating a shared key
    type CiphertextSize: ArraySize;

    /// A decapsulation key for this KEM
    type DecapsulationKey: Decapsulate<Ciphertext<Self>, SharedKey<Self>>
        + EncodedSizeUser
        + Debug
        + PartialEq;

    /// An encapsulation key for this KEM
    #[cfg(not(feature = "deterministic"))]
    type EncapsulationKey: Encapsulate<Ciphertext<Self>, SharedKey<Self>>
        + EncodedSizeUser
        + Clone
        + Debug
        + PartialEq;

    /// An encapsulation key for this KEM
    #[cfg(feature = "deterministic")]
    type EncapsulationKey: Encapsulate<Ciphertext<Self>, SharedKey<Self>>
        + EncapsulateDeterministic<Ciphertext<Self>, SharedKey<Self>>
        + EncodedSizeUser
        + Clone
        + Debug
        + PartialEq;

    /// Generate a new (decapsulation, encapsulation) key pair
    fn generate<R: CryptoRng + ?Sized>(
        rng: &mut R,
    ) -> (Self::DecapsulationKey, Self::EncapsulationKey);

    /// Generate a new (decapsulation, encapsulation) key pair deterministically
    #[cfg(feature = "deterministic")]
    fn generate_deterministic(d: &B32, z: &B32)
    -> (Self::DecapsulationKey, Self::EncapsulationKey);
}

/// `MlKem512` is the parameter set for security category 1, corresponding to key search on a block
/// cipher with a 128-bit key.
#[derive(Default, Clone, Debug, PartialEq)]
pub struct MlKem512Params;

impl ParameterSet for MlKem512Params {
    type K = U2;
    type Eta1 = U3;
    type Eta2 = U2;
    type Du = U10;
    type Dv = U4;
}

#[cfg(feature = "pkcs8")]
impl AssociatedOid for MlKem512Params {
    const OID: pkcs8::ObjectIdentifier = const_oid::db::fips203::ID_ALG_ML_KEM_512;
}

#[cfg(feature = "pkcs8")]
impl pkcs8::spki::AssociatedAlgorithmIdentifier for MlKem512Params {
    type Params = pkcs8::der::AnyRef<'static>;

    const ALGORITHM_IDENTIFIER: pkcs8::spki::AlgorithmIdentifier<Self::Params> =
        pkcs8::spki::AlgorithmIdentifier {
            oid: Self::OID,
            parameters: None,
        };
}

/// `MlKem768` is the parameter set for security category 3, corresponding to key search on a block
/// cipher with a 192-bit key.
#[derive(Default, Clone, Debug, PartialEq)]
pub struct MlKem768Params;

impl ParameterSet for MlKem768Params {
    type K = U3;
    type Eta1 = U2;
    type Eta2 = U2;
    type Du = U10;
    type Dv = U4;
}

#[cfg(feature = "pkcs8")]
impl AssociatedOid for MlKem768Params {
    const OID: pkcs8::ObjectIdentifier = const_oid::db::fips203::ID_ALG_ML_KEM_768;
}

#[cfg(feature = "pkcs8")]
impl pkcs8::spki::AssociatedAlgorithmIdentifier for MlKem768Params {
    type Params = pkcs8::der::AnyRef<'static>;

    const ALGORITHM_IDENTIFIER: pkcs8::spki::AlgorithmIdentifier<Self::Params> =
        pkcs8::spki::AlgorithmIdentifier {
            oid: Self::OID,
            parameters: None,
        };
}

/// `MlKem1024` is the parameter set for security category 5, corresponding to key search on a block
/// cipher with a 256-bit key.
#[derive(Default, Clone, Debug, PartialEq)]
pub struct MlKem1024Params;

impl ParameterSet for MlKem1024Params {
    type K = U4;
    type Eta1 = U2;
    type Eta2 = U2;
    type Du = U11;
    type Dv = U5;
}

#[cfg(feature = "pkcs8")]
impl AssociatedOid for MlKem1024Params {
    const OID: pkcs8::ObjectIdentifier = const_oid::db::fips203::ID_ALG_ML_KEM_1024;
}

#[cfg(feature = "pkcs8")]
impl pkcs8::spki::AssociatedAlgorithmIdentifier for MlKem1024Params {
    type Params = pkcs8::der::AnyRef<'static>;

    const ALGORITHM_IDENTIFIER: pkcs8::spki::AlgorithmIdentifier<Self::Params> =
        pkcs8::spki::AlgorithmIdentifier {
            oid: Self::OID,
            parameters: None,
        };
}

/// A shared key produced by the KEM `K`
pub type SharedKey<K> = Array<u8, <K as KemCore>::SharedKeySize>;

/// A ciphertext produced by the KEM `K`
pub type Ciphertext<K> = Array<u8, <K as KemCore>::CiphertextSize>;

/// ML-KEM with the parameter set for security category 1, corresponding to key search on a block
/// cipher with a 128-bit key.
pub type MlKem512 = kem::Kem<MlKem512Params>;

/// ML-KEM with the parameter set for security category 3, corresponding to key search on a block
/// cipher with a 192-bit key.
pub type MlKem768 = kem::Kem<MlKem768Params>;

/// ML-KEM with the parameter set for security category 5, corresponding to key search on a block
/// cipher with a 256-bit key.
pub type MlKem1024 = kem::Kem<MlKem1024Params>;

#[cfg(test)]
mod test {
    use super::*;

    fn round_trip_test<K>()
    where
        K: KemCore,
    {
        let mut rng = rand::rng();

        let (dk, ek) = K::generate(&mut rng);

        let (ct, k_send) = ek.encapsulate(&mut rng).unwrap();
        let k_recv = dk.decapsulate(&ct).unwrap();
        assert_eq!(k_send, k_recv);
    }

    #[test]
    fn round_trip() {
        round_trip_test::<MlKem512>();
        round_trip_test::<MlKem768>();
        round_trip_test::<MlKem1024>();
    }

    #[cfg(all(feature = "pkcs8", feature = "alloc"))]
    use pkcs8::{EncodePrivateKey, EncodePublicKey};

    #[cfg(all(feature = "pkcs8", feature = "alloc"))]
    fn der_serialization_and_deserialization<K>(expected_encaps_len: u16, expected_decaps_len: u16)
    where
        K: KemCore,
        K::EncapsulationKey: EncodePublicKey,
        K::DecapsulationKey: EncodePrivateKey,
    {
        use super::pkcs8::{EncodePrivateKey, PrivateKeyInfoOwned};
        use super::pkcs8::{EncodePublicKey, SubjectPublicKeyInfoRef};
        use pkcs8::der::{self, Decode};

        let mut rng = rand::rng();
        let (decaps_key, encaps_key) = K::generate(&mut rng);

        // TEST: serialize encapsulation key into DER document
        {
            let der_document = encaps_key.to_public_key_der().unwrap();
            let serialized_document = der_document.as_bytes();

            // deserialize encapsulation key from DER document
            let parsed = der::Document::from_der(&serialized_document).unwrap();
            assert_eq!(parsed.len(), der::Length::new(expected_encaps_len));

            // verify that original encapsulation key corresponds to deserialized encapsulation key
            let pub_key = parsed.decode_msg::<SubjectPublicKeyInfoRef>().unwrap();
            assert_eq!(
                encaps_key.as_bytes().as_slice(),
                pub_key.subject_public_key.as_bytes().unwrap()
            );
        }

        // TEST: serialize decapsulation key into DER document
        {
            use pkcs8::DecodePrivateKey;
            let der_document = decaps_key.to_pkcs8_der().unwrap();
            let serialized_document = der_document.as_bytes();

            // deserialize decapsulation key from DER document
            let parsed = der::SecretDocument::from_pkcs8_der(&serialized_document).unwrap();
            assert_eq!(parsed.len(), der::Length::new(expected_decaps_len));

            // verify that original decapsulation key corresponds to deserialized decapsulation key
            let priv_key = parsed.decode_msg::<PrivateKeyInfoOwned>().unwrap();
            assert_eq!(
                decaps_key.as_bytes().as_slice(),
                priv_key.private_key.as_bytes()
            );
        }
    }

    #[cfg(all(feature = "pkcs8", feature = "alloc"))]
    #[test]
    fn pkcs8_round_trip() {
        // NOTE: standardized encapsulation key sizes for MlKem{512,768,1024} are {800,1184,1568} bytes respectively.
        //       DER serialization adds 22 bytes. Thus we expect a length of {822,1206,1590} respectively.
        // NOTE: standardized decapsulation key sizes for MlKem{512,768,1024} are {1632,2400,3168} bytes respectively.
        //       DER serialization adds 24 bytes. Thus we expect a length of {1656,2424,3192} respectively.
        der_serialization_and_deserialization::<MlKem512>(822, 1656);
        der_serialization_and_deserialization::<MlKem768>(1206, 2424);
        der_serialization_and_deserialization::<MlKem1024>(1590, 3192);
    }
}
