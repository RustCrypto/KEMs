//! Trait definitions

use crate::{ArraySize, Seed};
use array::Array;
use core::fmt::Debug;
use kem::{Decapsulate, Encapsulate, InvalidKey};
use rand_core::CryptoRng;

/// An object that knows what size it is
pub trait EncodedSizeUser: Sized {
    /// The size of an encoded object
    type EncodedSize: ArraySize;

    /// Parse an object from its encoded form
    ///
    /// # Errors
    /// - If the object failed to decode successfully
    fn from_encoded_bytes(enc: &Encoded<Self>) -> Result<Self, InvalidKey>;

    /// Serialize an object to its encoded form
    fn to_encoded_bytes(&self) -> Encoded<Self>;
}

/// A byte array encoding a value the indicated size
pub type Encoded<T> = Array<u8, <T as EncodedSizeUser>::EncodedSize>;

/// A generic interface to a Key Encapsulation Method
pub trait KemCore: Clone {
    /// The size of a shared key generated by this KEM
    type SharedKeySize: ArraySize;

    /// The size of a ciphertext encapsulating a shared key
    type CiphertextSize: ArraySize;

    /// A decapsulation key for this KEM
    type DecapsulationKey: Decapsulate + EncodedSizeUser + Debug + PartialEq;

    /// An encapsulation key for this KEM
    type EncapsulationKey: Encapsulate + EncodedSizeUser + Clone + Debug + Eq + PartialEq;

    /// Generate a new (decapsulation, encapsulation) key pair.
    fn generate<R: CryptoRng + ?Sized>(
        rng: &mut R,
    ) -> (Self::DecapsulationKey, Self::EncapsulationKey);

    /// Generate a new (decapsulation, encapsulation) key pair deterministically from the given
    /// uniformly random seed value.
    fn from_seed(seed: Seed) -> (Self::DecapsulationKey, Self::EncapsulationKey);
}
